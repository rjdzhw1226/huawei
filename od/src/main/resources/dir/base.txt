#集合基础
ArrayList 底层是数组 Object[] 线程不安全 默认初始容量为10 查询效率高 维护动态数组的方法是扩容拷贝 指定容量创建 扩容效率较低
static List synchronizedList(List list) 传入ArrayList 返回线程安全的arrayList
eg:
Collections.synchronizedList(new ArrayList<String>());

Vector 底层是数组 初始容量为10 线程安全 初始容量为10 用完将扩大为原始容量的两倍

LinkedList 底层是一个双向链表 add方法只能加入链表的末尾 插入效率高

Set HashSet TreeSet 无序不重复 无下标

HashMap
线程不安全 底层实现从java8开始引入了红黑树
HashTable
线程安全 链表+数组
TreeMap
基于红黑树（red-black tree）数据结构实现，按key排序 默认的排序方式升序

二者继承的父类不同 但是都实现了Map接口

#数据结构
堆 一种完全二叉树
根节点下标为0
第i个数 左子节点下标为 left = 2i + 1
第i个数 右子节点下标为 right = 2i + 2
有n个元素的完全二叉树 最后一个非叶子节点的下标为 n/2 - 1

栈 后进先出
pop() 弹出
push() 压入
peek() 查看栈顶

队列 先进先出

图

二叉树/B树


链表


数组

树状数组
前置知识
lowbit(x)运算
如何计算一个非负整数n在二进制下的最低位1及其后面的0构成的数？
lowbit(x) = x & (-x)


#异常
Throwable
Error Exception
      IOException ClassNotFoundException RunTimeException CloneNotSupportedException
异常的顶级类是Throwable
Error是非程序异常 程序不能捕获 方法栈溢出 内存溢出
Exception是程序异常类，由程序内部产生 分为运行时异常和非运行时异常 编译不通过 需要代码抛出或者捕获处理 运行时异常

throw: 是真实抛出一个异常
throws: 是声明程序可能会抛出一个异常


#面试问题总结
list与string的互转
string转list
Arrays.stream(str.split(",")).map(e -> Integer.paseInt(e)).collect(Collects.toList());
list转string
Collectors.joining()
String.join()
第三方包 fastjson apache等

封装
隐藏内部细节 减少耦合 可复用 类似微服务这样 模块可用
继承
子类继承父类 可以使用非private的所有方法 子类对象可替换父类对象 向上转型 通过类的层次结构让代码整洁可读
多态
多态分为编译时多态和运行时多态:
编译时多态主要指方法的重载
运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定
运行时多态有三大要求
继承
覆盖
向上转型

抽象类
一个方法无法给出具体明确的，该方法可以声明为抽象方法
拥有抽象类方法的类，叫做抽象类

继承了抽象类的子类，要么对父类的抽象方法进行重写，要么自己也是抽象类
抽象类也可以拥有普通方法
抽象类不能创建对象
抽象类也有构造方法，但是是为了子类创建对象使用

接口

特殊的抽象类

不能实例化
没有构造方法
方法默认public abstract修饰
变量默认public static final修饰

接口是行为的抽象，是一种行为的规范，接口是like a 的关系；抽象是对类的抽象，是一种模板设计，抽象类是is a 的关系。
接口没有构造方法，而抽象类有构造方法，其方法一般给子类使用
接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
抽象体现出了继承关系，继承只能单继承。接口提现出来了实现的关系，实现可以多实现。接口强调特定功能的实现，而抽象类强调所属关系。
接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。
1.8接口中可以创建default方法和静态方法了

.java文件 源代码
.class文件 编译源代码 字节码文件
jvm 执行字节码文件
首先通过类加载器将字节码加载到内存当中 动态加载用到的类
通过字节码验证器来校验合法性
解释字节码为机器码去执行

redis的过期策略是定期删除+惰性删除
定期：每隔一段时间随机抽取一些有过期时间的key看看有没有过期过期就删除
惰性：当你请求这个key的时候看看有没有过期过期就删除并返回空
当长期不调用快满了的情况下就走内存淘汰机制
noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。

缓存穿透指的是数据库和缓存中都没有的数据 由于缓存是被动写的所以会导致一直查询数据库
一般解决方案是临时缓存一个这个key的null值 短过期时间

缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期）并发大
设置热点数据永不过期
接口限流与熔断，降级
布隆过滤器
加锁

缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机
多个key过期时间随机
采用多台数据库部署
设置热点数据不过期

String、StringBuffer、StringBuilder的区别
前两个线程安全 最后一个线程不安全
buffer适合大量多线程操作 builder适合单线程大量操作

== 和 equals
== 比较的是值 八个基本类型
   对象比较的是引用地址
equals Object的方法
比较的是两个对象的引用地址 重写hashcode和equals 则比较的是哈希值或者内容值



java线程调度算法和方式
抢占式调度和协同式调度
优先调度算法
短作业(进程)优先调度算法
高优先权优先调度算法
基于时间片的轮转调度算法


Java中线程通信方式
volatile关键字
用来修饰成员变量 告知程序对变量的访问需要从共享内存中取得数据
改变必须刷回共享内存 保证变量对所有线程的可见性

synchronized关键字
多线程互斥来保证临界区的安全 实现线程间通信
使用wait notify来实现等待唤醒

ReentrantLock/Condition 消息队列方式
使用消息队列的condition来实现等待唤醒
await signal

CountDownLatch来实现线程间通信 通常是多线程执行时用countDown来和主线程通信

死锁
使用同步线程访问一个或多个共享资源（变量和对象）或者指令集（临界区）发生 互相占用不释放
活锁
多个异步线程都拿到资源但都释放 不执行 最终没有线程执行

通过Socket网络通信

park and unpark（传入要唤醒的线程）

TCP是一种可靠的 面向连接的数据传输协议 数据有序 需要校验 发送前需要先建立连接
tcp的三次握手是为了确认双方的接受和发送能力是否正常

最开始的时候客户端和服务器都是处于CLOSED关闭状态。主动打开连接的为客户端，被动打开连接的是服务器。
TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN 监听状态
第一次握手 TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT 同步已发送状态
第二次握手 TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态
第三次握手 TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED已建立连接状态 触发三次握手

tcp的四次挥手

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。
第一次挥手 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态
第二次挥手 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态
第三次挥手 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成

客户端等待的目的是为了保证最后发送的第一个ack报文能到达服务器

泛型的底层原理
Java的泛型通过擦除的方式来实现。声明了泛型的 .java 源代码
在编译生成 .class 文件之后
泛型相关的信息就消失了。可以认为，源代码中泛型相关的信息，就是提供给编译器用的。
泛型信息对 Java 编译器可以见，对 Java 虚拟机不可见
通过
用 Object 或者界定类型替代泛型，产生的字节码中只包含了原始的类，接口和方法；
在恰当的位置插入强制转换代码来确保类型安全；
在继承了泛型类或接口的类中插入桥接方法来保留多态性。 实现了擦除 桥接方法保证了多态的使用 可以向上转型
Java 中的泛型有 3 种形式，泛型方法，泛型类，泛型接口。
Java 通过在编译时类型擦除的方式来实现泛型。擦除时使用 Object 或者界定类型替代泛型，同时在要调用具体类型方法或者成员变量的时候插入强转代码，为了保证多态特性，
Java 编译器还会为泛型类的子类生成桥接方法。类型信息在编译阶段被擦除之后，程序在运行期间无法获取类型参数所对应的具体类型。

bio aio nio的区别
同步 使用同步IO时，Java自己处理IO读写。
异步 使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS，完成后OS通知Java处理（回调）。
阻塞 使用阻塞IO时，Java调用会一直阻塞到读写完成才返回。
非阻塞 使用非阻塞IO时，如果不能立马读写，Java调用会马上返回，当IO事件分发器通知可读写时在进行读写，不断循环直到读写完成。

同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。
bio 服务端一旦接受连接 就可以建立通信套接字在这个通信套接字上进行读写操作 期间阻塞不在接受请求 通过多线程实现多链接
nio
Channel(通道)：通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。
Buffer(缓冲区)：Buffer是一个对象，它包含一些要写入或者要读出的数据
Selector(选择器)：选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来

aio 异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作
BIO是一个连接一个线程。
NIO是一个请求一个线程。
AIO是一个有效请求一个线程。

代码编写优化技巧
eg.java













